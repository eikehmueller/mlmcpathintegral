'''Script for visualising a configuration generated by the 
quenched Schwinger model

Reads data from the files passed as an input parameter, which contains two
lines, which look like this:

  N
  theta_0 theta_1 theta_2 ... theta_{N-1}

N is the number of links, and it is assumed to be N = 2*m^2, i.e. underlying lattice is assumed to be square.

The links are arranged as follows:

  |         |         |         |        |
  9        11        13        15       (9)
  |         |         |         |        |
  o--- 8 ---o--- 10 --o--- 12 --o-- 14 --o
  |         |         |         |        |
  1         3         5         7       (1)
  |         |         |         |        |
  o--- 0 ---o--- 2 ---o--- 4 ---o--- 6 --o

with time (index i) pointing to the right an space (index j) pointing upwards.

A link theta'_{(i,j),mu} starting at at site (i,j) and pointing in
direction mu has a linear index ell = 2*m*j + 2*i + mu, i.e. 
theta'_{(i,j),mu} = theta_ell, with the theta_ell stored in the file.
'''

import sys
import math
import numpy as np
from matplotlib import pyplot as plt

def mod_2pi(x):
    '''Map x into the range [-pi,pi)'''
    return x - 2.*math.pi*math.floor(0.5*(x+math.pi)/math.pi);

class Lattice2d(object):
    '''Square lattice of size m x m'''
    def __init__(self,m):
        self.m_lat = m_lat
        self.a_lat = 1./m_lat
    
    def lin2cart(self,ell):
        '''Convert linear index to Cartesian index'''
        j = ell // (2*self.m_lat)
        r = ell - (2*self.m_lat)*j;
        i = r//2
        mu = r % 2
        return i,j,mu

    def cart2lin(self,i,j,mu):
        '''Convert Cartesian index to linear index'''
        ell = 2*self.m_lat*(j%self.m_lat) + 2*(i%self.m_lat) + mu
        return ell

class Configuration(object):
    '''Configuration on lattice
    '''
    def __init__(self,lattice,data):
        self.lattice = lattice
        self.data = data

    def get_link(self,i,j,mu):
        '''Return link theta_{(i,j),mu}'''
        return self.data[self.lattice.cart2lin(i,j,mu)]

    def get_plaquette(self,i,j):
        '''Return plaquette theta_{(i,j),p}'''
        plaquette = mod_2pi( self.data[self.lattice.cart2lin(i,j,0)]
                             + self.data[self.lattice.cart2lin(i+1,j,1)]
                             - self.data[self.lattice.cart2lin(i,j+1,0)]
                             - self.data[self.lattice.cart2lin(i,j,1)] )
        return plaquette

def read_file(filename):
    '''Read data from file and return as an array'''
    print ('Reading data from file \"'+filename+'\"')
    with open(filename) as f:
        contents = f.readlines()
        data = np.asarray(contents[1].split(),dtype=float)
    n_data = len(data)
    print('Number of data points = ',n_data)
    assert n_data % 2 == 0, 'Number of data points has to be odd'
    m_lat = int(np.sqrt(n_data//2))
    assert 2*m_lat*m_lat == n_data, 'underlying lattice is not square'
    return data

def plot_config(config,out_filename,label=None):
    plt.clf()
    ax = plt.gca()
    ax.set_aspect('equal')
    ax.set_xlim(-0.1,1.1)
    ax.set_ylim(-0.1,1.1)
    m_lat = config.lattice.m_lat
    a_lat = config.lattice.a_lat
    for i in range(m_lat+1):
        for j in range(m_lat+1):
            # Plot plaquettes
            if (i < m_lat) and (j < m_lat):
                theta_ij_p = config.get_plaquette(i,j)
                rho = (theta_ij_p + math.pi)/(2.*math.pi)
                X = (a_lat*i, a_lat*(i+1), a_lat*(i+1), a_lat*i)
                Y = (a_lat*j, a_lat*j, a_lat*(j+1), a_lat*(j+1))
                plt.fill(X,Y,
                         color=(rho,rho,rho))
            # Plot links
            for mu in range(2):
                if ((i+1-mu) <= m_lat) and ((j+mu) <= m_lat):
                    theta_ij_mu = config.get_link(i,j,mu)
                    rho = (theta_ij_mu + math.pi)/(2.*math.pi)
                    X = (a_lat*i, a_lat*(i+1-mu))
                    Y = (a_lat*j, a_lat*(j+mu))
                    plt.plot(X,Y,
                             linewidth=2,
                             color=(rho,0,1-rho))
    if not (label is None):
        plt.title(label)
    plt.savefig(out_filename,bbox_inches='tight')

if __name__ == '__main__':
    if (len(sys.argv) < 2):
        print('Usage: python3 '+sys.argv[0]+' INFILENAME [OUTFILENAME]')
        sys.exit(-1)
    in_filename = sys.argv[1]
    data = read_file(in_filename)
    m_lat = int(math.sqrt(len(data)//2))
    lattice = Lattice2d(m_lat)
    config = Configuration(lattice,data)
    if (len(sys.argv)==3):
        out_filename = sys.argv[2]
    else:
        out_filename = 'configuration.pdf'
    plot_config(config,out_filename,label=in_filename)
    
